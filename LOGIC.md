# Логика работы бота

## Общая схема работы

```
Пользователь → Telegram → Бот → Яндекс.Диск → Обработка → Результат
```

## Детальная логика обработки

### 1. Получение сообщения
- **Точка входа**: `main.py` → `Dispatcher.start_polling()`
- Бот постоянно опрашивает Telegram API на новые сообщения
- Полученное сообщение передается в роутеры

### 2. Маршрутизация (`handlers/__init__.py`)
- **Порядок важен!**
  1. `start_router` - обрабатывает команды `/start`, `/help` и эхо
  2. `disk_handler_router` - обрабатывает ссылки на Яндекс.Диск

### 3. Проверка прав доступа (`handlers/disk_handler.py`)
```python
if not is_admin(user_id):
    return  # Игнорируем не-админов
```
- Проверяет, есть ли user_id в списке `ADMIN_IDS` из `config.py`
- Если нет - сообщение игнорируется

### 4. Распознавание ссылки
```python
if not is_yandex_disk_url(text):
    return  # Не обрабатываем
```
- Проверяет паттерны:
  - `yandex.ru/disk`
  - `yandex.ru/d/`
  - `yandex.ru/client/disk`

### 5. Парсинг ссылки (`yandex_disk.py::parse_disk_url()`)
- Извлекает путь к папке из разных форматов ссылок
- Декодирует URL-encoded пути
- Возвращает путь типа: `"folder/subfolder"`

### 6. Поиск видео файлов (`yandex_disk.py::get_video_files_from_folder()`)
- **Рекурсивный поиск**:
  1. Получает содержимое папки через API: `GET /v1/disk/resources`
  2. Для каждого элемента:
     - Если файл → проверяет расширение (`.mp4`, `.avi`, и т.д.)
     - Если папка → рекурсивно вызывает себя
  3. Возвращает плоский список всех видео

### 7. Отображение списка
- Показывает первые 20 файлов с размерами
- Обновляет статус сообщения

### 8. Обработка каждого видео (цикл)

#### 8.1. Скачивание (`yandex_disk.py::download_file()`)
```
Яндекс.Диск → Получение ссылки → Скачивание → Локальный файл
```
- Получает временную ссылку: `GET /v1/disk/resources/download`
- Скачивает файл через HTTP
- Сохраняет в `temp/video_N_name.ext`

#### 8.2. Конвертация (`video_converter.py::video_to_audio()`)
```
Видео файл → FFmpeg → Аудио файл (WAV, 16kHz, моно)
```
- Использует системную утилиту `ffmpeg`
- Параметры:
  - `-vn` - без видео
  - `-acodec pcm_s16le` - WAV кодек
  - `-ar 16000` - частота дискретизации (оптимально для Whisper)
  - `-ac 1` - моно канал
- Сохраняет в `temp/video_N_name.wav`

#### 8.3. Транскрибация (`transcription.py::transcribe()`)
```
Аудио файл → Whisper → Текст
```
- Загружает модель Whisper "base" (при первом использовании)
- Обрабатывает аудио через нейросеть
- Возвращает текст транскрипции
- Язык: русский (`language="ru"`)

#### 8.4. Сохранение и отправка
- Сохраняет текст в `temp/video_N_name.txt`
- Отправляет файл пользователю через `message.answer_document()`
- Удаляет временные файлы (видео, аудио, текст)

### 9. Финальный отчет
- Показывает статистику: обработано/ошибок/всего

## Поток данных

```
Ссылка на папку
    ↓
Парсинг → Путь к папке
    ↓
API Яндекс.Диска → Список файлов
    ↓
Фильтрация → Только видео
    ↓
Для каждого видео:
    ├─ Скачивание → temp/video.mp4
    ├─ Конвертация → temp/video.wav
    ├─ Транскрибация → "текст..."
    ├─ Сохранение → temp/video.txt
    └─ Отправка → Пользователю
    ↓
Очистка временных файлов
```

## Обработка ошибок

- **Нет доступа** → Игнорирование сообщения
- **Неверная ссылка** → Сообщение об ошибке
- **Нет видео** → Сообщение "не найдено"
- **Ошибка скачивания** → Пропуск файла, счетчик ошибок
- **Ошибка конвертации** → Пропуск файла
- **Ошибка транскрибации** → Пропуск файла
- **Общая ошибка** → Try/except с логированием

## Особенности

1. **Асинхронность**: Все операции неблокирующие (async/await)
2. **Рекурсивный поиск**: Находит видео во всех вложенных папках
3. **Автоочистка**: Временные файлы удаляются после обработки
4. **Статус в реальном времени**: Обновление сообщения о прогрессе
5. **Ограничения**: Показывает первые 20 файлов в списке


